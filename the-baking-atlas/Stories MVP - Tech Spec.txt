The Baking AtlasTechnical Specification Ñ Core MVP + StoriesAudience: Claude Code / Fullstack implementation assistantIntent: Describe the system architecture, data flow, and design considerations needed to support a storyfirst Baking Atlas today, while leaving room for future community contributions and editorial workflows.This spec is stackagnostic by design, but concrete enough to translate into implementation steps regardless of framework or language.1. System Goals (Technical)The system should:* Support readoptimized, editorial content (stories)* Treat stories as firstclass entities, not static pages* Allow association of stories with regions, themes, and time* Be designed for moderation and evolution, not immediate user publishing* Avoid premature optimization for engagement features2. HighLevel ArchitectureClient (Frontend)* Fullscreen interactive map as primary navigation surface* Secondary content surface for reading stories* Client never mutates canonical data directly (readonly for MVP)API Layer* Thin, explicit endpoints* Readheavy, cachefriendly* Clear separation between published content and submissionsData Layer* Relational or documentbased DB (either acceptable)* Editorial data modeled for evolution, not rigidityFuture Services (Not Implemented Yet)* Auth service* Moderation queue* Revision history / audit trail3. Core Domain Models (Conceptual)3.1 RegionRepresents a geographic anchor, not cultural truth.Key properties:* id* name (e.g. "Brazil")* type (country | subregion | region)* geometry reference (for map rendering)* parent_region_id (nullable)Important: Regions are navigational containers, not baking cultures.3.2 Story (Published)The primary narrative unit of The Baking Atlas.Key properties:* id* title* slug* body (markdown or rich text)* summary / excerpt* associated_regions (manytomany)* tags (ingredients, techniques, themes)* time_context (historical | modern | ongoing | mixed)* author_name (string for MVP)* sources (text or structured, optional but reserved)* published_at* updated_atDesign intent:* Stories must stand alone without map context* Map context enhances discovery, not meaning3.3 Tag (Lightweight)Used for crossstory discovery, not taxonomy enforcement.Examples:* Ingredient: cassava, rice, sugar* Technique: steaming, frying, stovetop* Theme: migration, climate, religionTags should be easy to add and easy to ignore.4. API Responsibilities4.1 Read Endpoints (MVP)* GET /regionso Returns regions with minimal metadatao Used to determine map state (e.g. highlighted countries)* GET /storieso Supports filters:* by region* by tag* by time_context* GET /stories/{slug}o Returns full story contentConstraints:* No pagination complexity initially (dataset small)* Responses optimized for reading, not editing4.2 Write Endpoints (Editorial Only, MVP)* POST /stories* PUT /stories/{id}Access:* Protected via simple auth or environmentbased controls* Assumes single editor (you)5. Frontend Data Flow (User Experience)Primary Flow (MVP)1. User lands on fullscreen map2. Map highlights regions with available content3. User selects a region4. A persistent side panel or overlay opens5. Panel displays:o Region contexto List of stories associated with that region6. User selects a story7. Story replaces list view in the same panelKey principle: No hard navigation between map and content.Secondary Flow (NonMap)* Users can access stories via:o Direct URLso Tagbased explorationMap is primary, but not mandatory.6. Content Rendering Considerations* Stories should be rendered as longform reading experiences* Support:o Headingso Inline emphasiso Quotes* Avoid:o Infinite scrollo Dense UI chromeTreat stories closer to essays than articles.7. NearFuture Design Considerations (Do Not Build Yet)7.1 User SubmissionsIntroduce a parallel model, not shared with published stories.Submission properties:* id* title* body* submitter_identifier (email or anon id)* associated_regions (optional)* status (pending | reviewed | accepted | rejected)* reviewer_notesNever allow submissions to appear publicly without review.7.2 Moderation & Editorial Control* Single canonical version of a published story* Submissions can be:o mergedo adaptedo rejectedDesign assumption:The Atlas grows through curation, not crowdsourcing alone.7.3 Versioning (Lightweight)Minimum viable approach:* updated_at* optional revision_notesFutureproofing:* Separate story_revisions table if needed8. Explicit NonGoals (For Now)* Public commenting* Likes or reactions* Algorithmic ranking* User profilesThese are deferred intentionally to protect content quality.9. Design Philosophy for ClaudeWhen implementing:* Prefer clarity over cleverness* Optimize for reading, not interaction density* Leave seams in the system where complexity can grow laterIf forced to choose:Preserve editorial integrity over feature completeness.10. Success Criteria (Technical)The system is successful if:* New stories can be added without frontend refactors* Stories can reference multiple regions cleanly* Map and story UI feel integrated, not toggled* Future features can be layered without breaking data modelsEnd of Technical Spec